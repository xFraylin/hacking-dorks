/**
 * Parsea wordlist.txt y genera wordlist-categories.ts con 4 arrays
 * Uso: node scripts/parse-wordlist.js
 * Lee: c:\Users\Fraylin\Downloads\wordlist.txt
 * Escribe: components/dork-data/wordlist-categories.ts
 */

const fs = require('fs');
const path = require('path');

const WORDLIST_PATH = path.join(process.env.USERPROFILE || '', 'Downloads', 'wordlist.txt');
const OUT_PATH = path.join(__dirname, '..', 'components', 'dork-data', 'wordlist-categories.ts');

const DORK_PREFIXES = /^(inurl:|intitle:|intext:|filetype:|allinurl:|allintitle:|site:|ext:)/i;
const HAS_OPERATOR = /(inurl:|intitle:|intext:|filetype:|allinurl:|allintitle:|site:|ext:)/i;

function isSectionHeader(line) {
  const t = line.toLowerCase();
  return (
    t.includes('google dorks for sql injection') ||
    t.includes('cctv camera online') ||
    t.includes('local file inclusion') ||
    t.includes('to gather sensitive data')
  );
}

function isDorkLine(line) {
  const s = line.trim();
  if (!s || s.length < 4) return false;
  if (isSectionHeader(s)) return false;
  if (/^[A-Z][a-z].*[.:]$/.test(s) && !HAS_OPERATOR.test(s)) return false; // descripciÃ³n
  return HAS_OPERATOR.test(s) || DORK_PREFIXES.test(s) || /^[("'!]/.test(s) || /\|/.test(s) || /-\s*site:/.test(s);
}

function parse(content) {
  const lines = content.split(/\r?\n/);
  const sections = {
    sql: [],
    cctv: [],
    lfi: [],
    sensitive: []
  };
  let current = null;

  for (let i = 0; i < lines.length; i++) {
    const raw = lines[i];
    const line = raw.trim();
    if (!line) continue;

    const lower = line.toLowerCase();
    if (lower.includes('google dorks for sql injection')) {
      current = 'sql';
      continue;
    }
    if (lower.includes('cctv camera online')) {
      current = 'cctv';
      continue;
    }
    if (lower.includes('local file inclusion')) {
      current = 'lfi';
      continue;
    }
    if (lower.includes('to gather sensitive data')) {
      current = 'sensitive';
      continue;
    }

    if (!current) continue;
    if (!isDorkLine(line)) continue;

    const dork = line.replace(/\s*site:\s*\{domain\}\s*$/, '').trim();
    const withDomain = dork + ' site:{domain}';
    if (sections[current].indexOf(withDomain) === -1) {
      sections[current].push(withDomain);
    }
  }

  return sections;
}

function escapeForTs(str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
}

function toTs(sections) {
  const lines = [
    '// Generated by scripts/parse-wordlist.js from wordlist.txt',
    '// Each dork ends with site:{domain} for optional domain filter.',
    '',
    `export const sqlInjectionDorks: string[] = [`,
    ...sections.sql.map((d) => `  "${escapeForTs(d)}",`),
    '];',
    '',
    `export const cctvDorks: string[] = [`,
    ...sections.cctv.map((d) => `  "${escapeForTs(d)}",`),
    '];',
    '',
    `export const lfiDorks: string[] = [`,
    ...sections.lfi.map((d) => `  "${escapeForTs(d)}",`),
    '];',
    '',
    `export const sensitiveDataDorks: string[] = [`,
    ...sections.sensitive.map((d) => `  "${escapeForTs(d)}",`),
    '];',
    ''
  ];
  return lines.join('\n');
}

if (!fs.existsSync(WORDLIST_PATH)) {
  console.error('Wordlist no encontrado:', WORDLIST_PATH);
  process.exit(1);
}

const content = fs.readFileSync(WORDLIST_PATH, 'utf8');
const sections = parse(content);

fs.mkdirSync(path.dirname(OUT_PATH), { recursive: true });
fs.writeFileSync(OUT_PATH, toTs(sections), 'utf8');
console.log('Escrito:', OUT_PATH);
console.log('SQLi:', sections.sql.length, 'CCTV:', sections.cctv.length, 'LFI:', sections.lfi.length, 'Sensitive:', sections.sensitive.length);
